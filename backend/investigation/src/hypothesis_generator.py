"""
Hypothesis Generator for the Investigation Agent.
Uses LLM to generate plausible attack paths and hypotheses.
"""

import json
import logging
from typing import Dict, List, Optional, Tuple, Any

from pydantic import BaseModel, Field

from backend.common.src.utils.bedrock_client import BedrockClient
from backend.investigation.src.tree import InvestigationTree, TreeNode, NodeType, NodeStatus

logger = logging.getLogger(__name__)

class HypothesisCandidate(BaseModel):
    """A candidate hypothesis generated by the LLM."""
    title: str
    description: str
    type: NodeType
    confidence: float = Field(ge=0.0, le=1.0)
    evidence: List[str] = Field(default_factory=list)
    reasoning: str


class HypothesisRequest(BaseModel):
    """Request for generating hypotheses."""
    breach_description: str
    context: Optional[str] = None
    parent_node: Optional[Dict] = None
    path_to_root: List[Dict] = Field(default_factory=list)
    related_vulnerabilities: List[Dict] = Field(default_factory=list)
    num_hypotheses: int = 3


class HypothesisResponse(BaseModel):
    """Response containing generated hypotheses."""
    hypotheses: List[HypothesisCandidate]
    analysis: str


class HypothesisGenerator:
    """
    Generator for hypotheses in the investigation tree.
    Uses LLM to generate plausible attack paths and hypotheses.
    """
    
    def __init__(self, bedrock_client: Optional[BedrockClient] = None):
        """
        Initialize the hypothesis generator.
        
        Args:
            bedrock_client: Optional BedrockClient instance
        """
        self.bedrock_client = bedrock_client or BedrockClient()
        
    def _create_prompt(self, request: HypothesisRequest) -> str:
        """
        Create a prompt for the LLM to generate hypotheses.
        
        Args:
            request: The hypothesis request
            
        Returns:
            Prompt string for the LLM
        """
        prompt = f"""
You are a cybersecurity expert analyzing a potential security breach. 
Your task is to generate plausible hypotheses for the next steps in the attack path.

BREACH DESCRIPTION:
{request.breach_description}

"""
        
        if request.context:
            prompt += f"""
ADDITIONAL CONTEXT:
{request.context}

"""
        
        if request.parent_node:
            prompt += f"""
CURRENT NODE IN INVESTIGATION:
Type: {request.parent_node.get('type')}
Title: {request.parent_node.get('title')}
Description: {request.parent_node.get('description')}

"""
        
        if request.path_to_root:
            prompt += "PATH TO ROOT:\n"
            for i, node in enumerate(request.path_to_root):
                prompt += f"{i+1}. [{node.get('type')}] {node.get('title')}: {node.get('description')}\n"
            prompt += "\n"
        
        if request.related_vulnerabilities:
            prompt += "RELATED VULNERABILITIES:\n"
            for i, vuln in enumerate(request.related_vulnerabilities):
                prompt += f"{i+1}. {vuln.get('id')}: {vuln.get('description', '')}\n"
            prompt += "\n"
        
        prompt += f"""
Generate {request.num_hypotheses} plausible hypotheses for what might have happened next in this security breach.
For each hypothesis, provide:
1. A concise title
2. A detailed description
3. The type of node (one of: root, vulnerability, attack_vector, impact, mitigation)
4. A confidence score between 0.0 and 1.0
5. Any evidence supporting this hypothesis
6. Your reasoning for this hypothesis

Your response should be structured and detailed, focusing on technically plausible attack paths.
"""
        
        return prompt
    
    def generate_hypotheses(self, request: HypothesisRequest) -> HypothesisResponse:
        """
        Generate hypotheses based on the request.
        
        Args:
            request: The hypothesis request
            
        Returns:
            Response containing generated hypotheses
        """
        prompt = self._create_prompt(request)
        
        try:
            # Get structured output from the LLM
            response = self.bedrock_client.get_structured_output(
                prompt=prompt,
                response_model=HypothesisResponse,
                model_id="mistral.mistral-7b-instruct-v0:2"
            )
            
            return response
            
        except Exception as e:
            logger.error(f"Error generating hypotheses: {e}")
            # Return a fallback response with a single hypothesis
            return HypothesisResponse(
                hypotheses=[
                    HypothesisCandidate(
                        title="Error generating hypothesis",
                        description=f"An error occurred while generating hypotheses: {str(e)}",
                        type=NodeType.ATTACK_VECTOR,
                        confidence=0.1,
                        evidence=[],
                        reasoning="This is a fallback hypothesis due to an error in generation."
                    )
                ],
                analysis="Error occurred during hypothesis generation."
            )
    
    def generate_initial_nodes(
        self, 
        tree: InvestigationTree, 
        breach_description: str,
        num_nodes: int = 3
    ) -> List[str]:
        """
        Generate initial nodes for the investigation tree.
        
        Args:
            tree: The investigation tree
            breach_description: Description of the breach
            num_nodes: Number of initial nodes to generate
            
        Returns:
            List of node IDs for the generated nodes
        """
        request = HypothesisRequest(
            breach_description=breach_description,
            num_hypotheses=num_nodes
        )
        
        response = self.generate_hypotheses(request)
        
        node_ids = []
        for hypothesis in response.hypotheses:
            node = TreeNode(
                type=hypothesis.type,
                title=hypothesis.title,
                description=hypothesis.description,
                confidence=hypothesis.confidence,
                evidence=hypothesis.evidence,
                metadata={"reasoning": hypothesis.reasoning}
            )
            
            node_id = tree.add_node(node)
            node_ids.append(node_id)
        
        return node_ids
    
    def generate_next_level(
        self, 
        tree: InvestigationTree, 
        parent_id: str,
        related_vulnerabilities: List[Dict] = None,
        num_nodes: int = 3
    ) -> List[str]:
        """
        Generate the next level of nodes for a given parent node.
        
        Args:
            tree: The investigation tree
            parent_id: The ID of the parent node
            related_vulnerabilities: Optional list of related vulnerabilities
            num_nodes: Number of nodes to generate
            
        Returns:
            List of IDs of the generated nodes
        """
        parent_node = tree.get_node(parent_id)
        if not parent_node:
            return []
        
        # Get the path from root to the parent node
        path_to_root = tree.get_path_to_root(parent_id)
        
        # Create the request
        request = HypothesisRequest(
            breach_description=path_to_root[0].get("description", "") if path_to_root else "",
            parent_node=parent_node,
            path_to_root=path_to_root,
            related_vulnerabilities=related_vulnerabilities or [],
            num_hypotheses=num_nodes
        )
        
        # Generate hypotheses
        response = self.generate_hypotheses(request)
        
        # Add nodes to the tree
        node_ids = []
        for hypothesis in response.hypotheses:
            node = TreeNode(
                parent_id=parent_id,
                type=hypothesis.type,
                title=hypothesis.title,
                description=hypothesis.description,
                confidence=hypothesis.confidence,
                evidence=hypothesis.evidence,
                metadata={"reasoning": hypothesis.reasoning}
            )
            
            node_id = tree.add_node(node)
            node_ids.append(node_id)
        
        return node_ids